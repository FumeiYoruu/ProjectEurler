# ProjectEurler
Dec 12th 1:00am-2:00am
I finished problem 1 through 5 in the work session. The first 4 questions are quite successful and problem five is kind of a roadblock to me. At first I iterate from 20 to 1, if the product cannot be divided by the number, then I time the number. However, I realized there is a problem of redundant prime factors, Therefore, I chose to count the number of each prime factor with a dictionary.
Dec 15th 7:10pm - 8:10pm
I finished problem 6 through 10 in this work session. Most of the questions focuses on prime. I just used the same method to find prime numbers on every one of them. The roadblock is on #8 when there is a long integer for input and I needed to iterate over every digit of it. Finally I came up with the idea to take it as a string which made the iteration much easier.
Jan 5th 8:00pm-9:00pm
I finished problem 12 through 18 except 17 and 14 because of input issues. The main obstacle I face is problem 18. The other problems can be solved trickfully with strings in python and long int type in python. However, problem 18 requires some dynamic programming and needs to store a tree. I have problems storing trees in python; therefore I decided to use c++. Then, it is rather easy. Just make a matrix that stores the max of sum on every point of the triangle and find the greatest one. 
Jan 7th 4:00pm-5:00pm
I completed problem 18 through 21. Problem 21 is rather a hard one because I did not understand the problem prompt quite well. I thought amicable pairs can be the same number and stuck on this part for a long time. Finally, after rereading the prompt and finding out that a!=b, I solved the problem simply. Problem 19 is difficult as well. I came up with the idea of storing the number of days in an array to run the problem with a loop.
Jan 13th 6:30pm-7:30pm
I complted problem 23 through 25. Problem 23 is an annoying one as there are a lot of steps needed. Determining whether a number is abundant or not every time consumes too much time when run; therefore, I first store the abundant numbers below 28123 in a dictionary, accessing that would be much easier. Problem 24 is also tricky as it is a typical depth-first search problem. Writing the code requires much patience and carefulness as it is easy to cause errors when writing recursions. 
