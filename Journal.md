# ProjectEurler
Dec 12th 1:00am-2:00am (I renamed the files on Jan 18th because I forgot to number them; therefore, the time of commitment has changed)
I finished problem 1 through 5 in the work session. The first 4 questions are quite successful and problem five is kind of a roadblock to me. At first I iterate from 20 to 1, if the product cannot be divided by the number, then I time the number. However, I realized there is a problem of redundant prime factors, Therefore, I chose to count the number of each prime factor with a dictionary.
Dec 15th 7:10pm - 8:10pm (Problem 9 is updated on Jan 18th)
I finished problem 6 through 10 in this work session. Most of the questions focuses on prime numbers. I just used the same method to find prime numbers on every one of them. The roadblock is on #8 when there is a long integer for input and I needed to iterate over every digit of it. Finally I came up with the idea to take it as a string which made the iteration much easier. With the string, I can iterate over every digit of the number easily.
Jan 5th 8:00pm-9:00pm
I finished problem 12 through 18 except 17 and 14 because of input issues. The main obstacle I face is problem 18. The other problems can be solved trickfully with strings in python and long int type in python. However, problem 18 requires some dynamic programming and needs to store a tree. I have problems storing trees in python; therefore I decided to use c++. Then, it is rather easy. Just make a matrix that stores the max of sum on every point of the triangle and find the greatest one. 
Jan 7th 4:00pm-5:00pm
I completed problem 18 through 21. Problem 21 is rather a hard one because I did not understand the problem prompt quite well. I thought amicable pairs can be the same number and stuck on this part for a long time. Finally, after rereading the prompt and finding out that a!=b, I solved the problem simply. Problem 19 is difficult as well. I came up with the idea of storing the number of days in an array to run the problem with a loop.
Jan 13th 6:30pm-7:30pm
I complted problem 23 through 25. Problem 23 is an annoying one as there are a lot of steps needed. Determining whether a number is abundant or not every time consumes too much time when run; therefore, I first store the abundant numbers below 28123 in a dictionary, accessing that would be much easier. Problem 24 is also tricky as it is a typical depth-first search problem. For every recursion, the code goes over the value on one position of the permutation. Writing the code requires much patience and carefulness as it is easy to cause errors when writing recursions. 
Jan 14th 5:30pm - 6:30pm (Probem 26 is renamed on Jan 18th because I forgot to add the py suffix)
I finished #26 and #27. Number 26 is a great challenge for me. At first, I used the method of finding the first 100000 digits of the decimal and find the length of the cycle using a loop. However, it takes too much time and the code never ends. Finally, I found out that every time two digits in the decimal result in the same remainder, a reciprocal cycle occurs. After knowing this, the problem becomes much easier. For problem 27, I used brute force to calculate for every a and b value. I found the max rather easily. I used a prime detecting funtion that I wrote formerly on other problems.
Jan 18th 7:30pm - 8:30pm (Replacement for Day 24-25)
I finished problems #28 through #33 except #32. Problem 28 and 29 went smoothly. For 28, I found out a pattern in the diagonal numbers and solved easily. Porblem 29, I solved with brute force. Problem 30 is rather tricky as I have do determine the greatest number to test. I realized that I can first use a loop to find out the greatest number than start the main code. Problem 31 is very hard and I solved it with dynamic programming, it is hard to example so I recommend reading my code and comments on that one. Problem 33 went smoothly as well. I brute forced every two digit number and see if it suits the situation.
